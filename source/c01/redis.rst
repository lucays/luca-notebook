========
redis
========

| Q. redis的数据结构和实现

| A. 

   | 字符串 列表 hash表 集合 有序集合
   | 列表由ziplist或者链表实现
   | hash表由ziplist或者hash表实现
   | 集合由整数集合或者value为null的hash表实现
   | 有序集合由ziplist或者跳跃表实现

| Q. redis为什么快？

| A. 

   | 纯内存操作
   | 优化的数据结构
   | I/O多路复用模型，监听多路文件描述符的可读写状态

| Q. redis为什么是单线程的

| A. 

   | 性能瓶颈不在CPU上，单线程方便维护不用加锁，I/O多路复用模型已经很好的处理并发的请求
   | 不过redis6.0还是引入了多线程，这是因为对redis的性能有了更高的要求，主要处理网络数据的读写和协议解析（序列化和反序列化成能理解的数据结构），实际执行命令还是串行执行的

| Q. redis的数据淘汰策略

| A. 

   | 主要是lru（淘汰最近最少使用的数据）, lfu（淘汰最不经常使用的数据）, ttl（淘汰将要过期的数据）, random（随机淘汰数据）和不淘汰数据，满了报错等机制。
   | 此外从所有key中淘汰和从设置了过期时间的key中淘汰又分为两种。

| Q. 手写一个lru算法？

| A. 

   | hash+链表

| Q. 缓存穿透 缓存击穿 缓存雪崩 分别是什么 解决方案

| A. 

   | 缓存穿透：请求了缓存里没有，数据库也没有的数据，如-1等。解决方法是加接口校验，或者加布隆过滤器判断，不在里面的直接丢弃。
   | 缓存击穿：大量请求某个热点key，在这个key失效时，流量打到数据库上，导致击穿。解决办法是设置热点key不过期，或者加锁，并发线程里只有1个去请求数据库，获取值并写入缓存后释放锁，就又会从redis拿数据了。
   | 缓存雪崩：大量key在同一时间失效，导致大流量打到数据库上。如果是redis挂了，增加redis集群，以及做限流。如果是key过期时间都一样，修改为随机的过期时间，或者永不过期。

| Q. 布隆过滤器是什么，实现原理是

| A. 

   | 布隆过滤器是一种高效判定key是否存在的数据结构，相对于hashmap来说，布隆过滤器用bitmap实现，即使存了大量的key占用内存也很小，缺点是可能误判，删除某个key也不方便。
   | 实际存储key时根据多个hash函数来计算，把对应的下标置为1，检查时也根据这些hash函数计算，查看对应的下标是否都为1，如果有1个不为1，那么一定不在。如果都为1，由于存在hash冲突，只能说很可能存在。

| Q. 负载均衡算法 一致性hash

| A. 

   | 一致性hash是为了解决余数hash等算法在某个服务器故障时缓存全部失效而产生的
   | 主要特点就是hash结果在一个环上，先计算服务器在环上的位置，再用相同的hash算法计算数据在环上的位置，然后去找最近的节点，缓存到那个节点上。
   | 即使某个服务器挂了，也不会导致缓存全部失效。

| Q. redis的持久化方式

| A. 

   | AOF和RDB
   | AOF是每次写操作都会追加写入日志，对磁盘友好，且可读性好，不过性能没有RDB好。
   | RDB是定时写入日志，如果宕机可能会丢失上次写入到当前之间的数据。恢复速度快，不过可读性不佳，以及生成备份时如果文件很大，可能会卡住。
   | 如果丢失数据，先RDB快速恢复，再AOF补全数据。

| Q. redis的事务特点

| A. 

   | redis只是部分支持事务，不如说是命令打包功能。如果一条命令失败，之后能执行的命令还会执行。就隔离性来说，事务中的一系列命令在最终提交之前都不会实际执行，因此没有隔离性问题。
