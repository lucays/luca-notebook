=========
other
=========

| Q. 进程线程协程的概念和区别

| A. 

   | 进程：简单理解就是一个独立运行的程序。可能由多个进程组成。进程是操作系统分配调度资源的独立单位。进程比较重，进程间通信比较麻烦，而且上下文切换开销比较大。
   | 线程：是进程中的实际运作单位，真正做事的。它是程序执行的最小单位。一个进程可以开多个线程。线程不可控，调试麻烦，多线程之间也有上下文切换的开销。
   | 协程：轻量级线程，用户自己在进程中实现的可以用来调度资源的工具。非抢占式，不是系统级别而是解释器/编译器/虚拟机层面的概念。多个协程可能在一个线程上运行。上下文切换的开销最小。

| Q. 进程间如何通信？

| A. 

   | 管道，消息队列（queue），共享内存（Python3.9支持），信号，socket套接字等。

| Q. 僵尸进程和孤儿进程

| A. 

   | 僵尸进程就是子进程退出时，父进程却没有调用wait/waitpid获取子进程状态，于是子进程的进程描述符仍然保留在系统中，而一个系统能使用的进程号有限，可能会导致不能产生新的进程。解决办法就是找到这个父进程，杀掉，子进程就变成孤儿进程了。
   | 孤儿进程就是父进程已经退出了，子进程还在，会被init进程定时回收，没有影响。

| Q. 解释三次握手和四次挥手

| A. 

   | 三次握手：1. 客户端向服务端发送SYN信息，并初始化序列号seq。2. 服务端接收到信息后，回发给客户端SYN+ACK（seq+1）信息，也初始化了服务端的序列号seq。3. 客户端接收到信息后，发送ACK（服务端的seq+1）信息，建立起连接。第3次握手时可以携带数据。
   | 四次挥手：1. 客户端向服务端发送FIN信息，并初始化序列号seq。2. 服务端接收到后，回发ACK报文，序列号是seq+1。3. 如果服务端也想关闭连接，会再发一个FIN报文，并初始化序列号seq。4. 客户端收到FIN报文后，回发一个ACK报文，序列号是收到的seq+1。这时处于TIME_WAIT状态，如果过2MSL（最大报文生存时间）服务端没有回发FIN报文，就认为服务端接收到了这个ACK报文并正常关闭了，于是客户端也关闭了连接。

| Q. 为什么要三次握手和四次挥手

| A. 

   | 通过三次握手才能阻止重复历史连接。如果两次握手，网络较差时，客户端多次发送了数据，服务端接受后可能产生错误的连接，浪费资源。如果是三次握手，服务端接受后回发数据时，客户端不会作最后那次的发送（因为是失效数据），也就避免了这个情况。
   | 四次挥手是因为服务端接收到客户端的FIN报文后，通常还有数据要处理，所以会分开发ACK和FIN报文。

| Q. 四次挥手时TIME_WAIT状态的意义

| A. 

   | 主要是保证客户端发送的ACK服务端成功收到了。如果服务端没收到，在2MSL时间内会重发FIN报文。
   | 此外，2MSL时间内旧报文都从网络中消失了，之后新的连接中就不会出现旧的报文。

| Q. rabbitmq和kafka的区别

| A. 

   | kafka适合吞吐量大的场景，rabbitmq适合需要可靠性高，对性能要求不高的场景。

| Q. kafka为什么性能好？

| A. 

   | 首先，消息是批处理的，减少网络开销。其次，磁盘是顺序写的，减少寻道开销。然后，采用PageCache加速，减少磁盘IO开销。最后，通过操作系统的sendfile实现零拷贝技术，从PageCache直接把数据拷贝到socket，减少拷贝开销。

| Q. 为什么离开上家公司？


| Q. 最深刻的一次经历

